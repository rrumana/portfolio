---
import SectionShell from '../layout/SectionShell.astro';
import AccordionGroup from '../patterns/AccordionGroup.astro';
import Accordion from '../patterns/Accordion.astro';
import SurfaceCard from '../ui/SurfaceCard.astro';
import FeatureGrid from '../patterns/FeatureGrid.astro';
import CommandCard from '../patterns/CommandCard.astro';
import Callout from '../callouts/Callout.astro';
import Heading from '../ui/Heading.astro';
import Text from '../ui/Text.astro';
import Button from '../ui/Button.astro';

const optimizationSections = [
  {
    title: 'Engine Overview',
    content: `<p>This represents the best version yet of my Game of Life engine, delivering a <strong>~10,000x performance improvement</strong> over the first naive implementation through bit manipulation and hardware-accelerated computation. Benchmarks regularly hit <strong>158 billion cell updates per second</strong> on a laptop-class CPU, and there is still room to experiment.</p>
      <p>The engine automatically detects hardware capabilities and picks the optimal SIMD configuration, supporting widths of 4, 8, or 16 parallel operations. It uses configurable generic parameters <code class="code-snippet">UltimateEngine&lt;const N: usize&gt;</code> where N represents the SIMD lane count, allowing compile-time optimization for specific targets.</p>`
  },
  {
    title: 'Bit-Packed Representation',
    content: `<p>The engine stores 64 cells per u64 integer, achieving <strong>8x memory efficiency</strong> compared to byte-per-cell representations. This bit-packing strategy dramatically improves cache performance and enables vectorized operations on large cell groups simultaneously.</p>
      <p>Grid layout uses MSB-first bit ordering with strategic padding which eliminates boundary checks during computation, while SIMD alignment ensures optimal memory access patterns. Pre-computed boundary masks handle edge cases efficiently without conditional branching in the hot path.</p>`
  },
  {
    title: 'SIMD Vectorization',
    content: `<p>The engine leverages Rust's portable SIMD to process multiple 64-bit words simultaneously. Custom shift operations <code class="code-snippet">shl()</code> and <code class="code-snippet">shr()</code> handle cross-lane bit propagation using <code class="code-snippet">rotate_elements_left/right</code> with pre-selected masks to maintain bit continuity across SIMD lanes. Using 8 SIMD lanes represents a <strong>512x</strong> speedup compared to byte-per-cell representations.</p>
      <p>Memory prefetching on x86_64 architectures uses <code class="code-snippet">_mm_prefetch</code> with <code class="code-snippet">_MM_HINT_T0</code> to load next rows into L1 cache before processing, reducing memory latency. The engine processes columns in SIMD-aligned chunks, maximizing instruction-level parallelism and minimizing cache misses.</p>`
  },
  {
    title: 'Neighbor Counting Algorithm',
    content: `<p>The core <code class="code-snippet">sub_step()</code> function implements an optimized full/half adder algorithm for counting neighbors. Rather than iterating through 8 neighbors individually, it uses a two-stage binary tree reduction to compute neighbor counts for all 64 cells in parallel.</p>
      <p>Neighbors are grouped into pairs using XOR for sum bits and AND for carry bits and then combined. The Game of Life rules are applied using bitwise operations: <code class="code-snippet">center |= ab; center &= b3 ^ b4; center &= !c0;</code> eliminating conditional branching in the hotpath, allowing the vectorization to remain efficient.</p>`
  },
  {
    title: 'Parallel Processing',
    content: `<p>Workloads are divided into row blocks that can be processed independently across threads. The scheduler balances work dynamically to avoid idle cores during uneven workloads.</p>
      <p>Prefetch distance is tuned per architecture to maximize cache utilization; block sizes are chosen to maintain cache locality while minimizing synchronization overhead between worker threads.</p>`
  },
  {
    title: 'WebAssembly Integration',
    content: `<p>Wasm SIMD is used when supported, providing significant performance improvements in modern browsers. The engine gracefully handles hardware limitations with automatic fallback to scalar implementations, ensuring compatibility across all platforms while maximizing performance on capable hardware.</p>
      <p>Because the UI is powered by wasm-bindgen, the same Rust codebase drives both the native solver and the interactive web experience.</p>`
  },
  {
    title: 'Future Work',
    content: `<p>Several optimization vectors remain unexplored. Current benchmarks show memory bandwidth saturation as the primary bottleneck, with CPU utilization plateauing at roughly 50% because of DRAM throughput. Future work includes experimenting with alternative memory layouts, smarter software prefetching, and adaptive block sizes tuned per architecture.</p>
      <p>The scalar build already handled ~12 million cell updates per second‚Äîwhich is more than enough for the web demo‚Äîbut this project is an excuse to chase theoretical limits. GPU-backed variants and distributed solving strategies are on the roadmap.</p>`
  }
];

const proofSections = [
  {
    title: 'Definitions & Setup',
    content: String.raw`<p>Let <span class="math-term">Œ£ = {0,1}</span>. For a finite grid of size <span class="math-term">N √ó N</span>, a configuration is a function:</p>
      <div class="formula">\[ c: \{0,1,\dots,N-1\}^2 \to \{0,1\}. \]</div>
      <p>Define the local update rule of Conway's Game of Life:</p>
      <div class="formula">\[ f: \{0,1\}^{N \times N} \to \{0,1\}^{N \times N} \]</div>
      <p>by</p>
      <div class="formula">\[
      f(c)(i,j) = \begin{cases}
          1 & \text{if } c(i,j)=1 \text{ and } n(i,j) \in \{2,3\}, \\
          1 & \text{if } c(i,j)=0 \text{ and } n(i,j)=3, \\
          0 & \text{otherwise},
      \end{cases}
      \]</div>
      <p>where the neighbor count is:</p>
      <div class="formula">\[
      n(i,j) = \sum_{(d_1,d_2) \in \{-1,0,1\}^2 \setminus \{(0,0)\}} c(i+d_1,j+d_2).
      \]</div>`
  },
  {
    title: 'Main Theorem',
    content: String.raw`<p><strong>Theorem:</strong> The decision problem REV-GOL is NP-Complete.</p>
      <div class="formula">\[
      \text{REV-GOL} = \{\, c \in \{0,1\}^{N \times N} \mid \exists\, p \in \{0,1\}^{N \times N} \text{ such that } f(p)=c \,\}.
      \]</div>
      <p>In other words, REV-GOL asks: "Given a Game of Life configuration <span class="math-term">c</span>, does there exist a predecessor configuration <span class="math-term">p</span> such that applying one step of the Game of Life rules to <span class="math-term">p</span> produces <span class="math-term">c</span>?"</p>`
  },
  {
    title: 'NP Membership',
    content: '<p><strong>REV-GOL ‚àà NP:</strong> A nondeterministic algorithm can guess a candidate predecessor <span class="math-term">p</span> and verify in <span class="math-term">O(N¬≤)</span> time that <span class="math-term">f(p) = c</span>.</p><p>The verification process simply applies the Game of Life rules to each cell in the guessed configuration and checks if the result matches the given configuration.</p>'
  },
  {
    title: 'NP-Hardness',
    content: '<p>We reduce from 3-SAT. Each boolean variable is modeled using paired wires that encode its true/false states, and clause gadgets ensure at least one incident literal satisfies the clause.</p><p>The reduction ensures the constructed configuration has a predecessor if and only if the original 3-SAT formula is satisfiable.</p>'
  },
  {
    title: 'Gadget Construction',
    content: String.raw`<p>Variable gadgets propagate signals along synchronized wires so clauses receive consistent timing. Clause gadgets OR the incoming literals and feed a verification grid.</p>
      <div class="formula">\[
      G = \left( \bigcup_{i=1}^n V_i \right) \cup \left( \bigcup_{i=1}^m G_{C_i} \right) \cup (\text{background})
      \]</div>
      <p>Additional supporting gadgets handle carry propagation and enforce the timing constraints needed for reversible evolution.</p>`
  },
  {
    title: 'Concrete Example',
    content: String.raw`<p>Consider the 3-SAT formula:</p>
      <div class="formula">\[ \phi = (x_1 \vee \neg x_2 \vee x_3) \wedge (\neg x_1 \vee x_2 \vee \neg x_3) \]</div>
      <p><strong>Clause 1:</strong> <span class="math-term">(x‚ÇÅ ‚à® ¬¨x‚ÇÇ ‚à® x‚ÇÉ)</span> is satisfied when at least one of:</p>
      <div class="formula">\[
      x_1 \text{ is True } (P_{1,T}), \quad x_2 \text{ is False } (P_{2,F}), \quad x_3 \text{ is True } (P_{3,T})
      \]</div>
      <p><strong>Clause 2:</strong> <span class="math-term">(¬¨x‚ÇÅ ‚à® x‚ÇÇ ‚à® ¬¨x‚ÇÉ)</span> is satisfied when at least one of:</p>
      <div class="formula">\[
      x_1 \text{ is False } (P_{1,F}), \quad x_2 \text{ is True } (P_{2,T}), \quad x_3 \text{ is False } (P_{3,F})
      \]</div>`
  },
  {
    title: 'Conclusion',
    content: '<p>Thus, <span class="math-term">c_œÜ</span> has a predecessor if and only if <span class="math-term">œÜ</span> is satisfiable. Since 3-SAT is NP-complete and REV-GOL ‚àà NP, it follows that <strong>REV-GOL is NP-complete</strong>.</p><p>All progress will be posted on my GitHub first before making its way here.</p>'
  }
];

const architectureComponents = [
  {
    title: 'Configuration Management',
    description: 'YAML-based configuration system supporting flexible parameter tuning for grid size, generations, solver backends, optimization levels, and output formats.'
  },
  {
    title: 'Game of Life Engine',
    description: 'Core cellular automaton implementation with grid representation, rule application, I/O operations, and support for multiple boundary conditions (dead, wrap, mirror).'
  },
  {
    title: 'SAT Encoding & Solving',
    description: 'Converts Game of Life constraints into SAT problems with support for multiple backends: CaDiCaL (single-threaded) and ParKissat-RS (multithreaded) solvers.'
  },
  {
    title: 'Reverse Problem Solving',
    description: 'Handles problem definition, solution extraction, validation through forward simulation, and comprehensive output formatting with pattern analysis.'
  },
  {
    title: 'Utility & Display',
    description: 'Provides display utilities, output formatting, benchmarking tools, and comprehensive logging for performance analysis and debugging.'
  }
];

const solverFeatures = [
  {
    title: 'Flexible Configurations',
    description: 'Support for multiple grid sizes, generation depths, solver backends, and optimization levels through YAML configuration files.',
    icon: 'üß©'
  },
  {
    title: 'Solver Backends',
    description: 'Integrates CaDiCaL (single-threaded) and ParKissat-RS (multithreaded) solvers for optimal performance across different problem sizes.',
    icon: '‚öôÔ∏è'
  },
  {
    title: 'Multithreaded Solving',
    description: 'ParKissat-RS backend provides parallel SAT solving capabilities for complex problems with large grids and multiple generations.',
    icon: 'üßµ'
  },
  {
    title: 'Multiple Solution Finding',
    description: 'Discovers all valid predecessor states up to a configurable limit using iterative SAT solving with hybrid encoding strategies.',
    icon: 'üîç'
  },
  {
    title: 'Solution Validation',
    description: 'Verifies found solutions by forward simulation to ensure correctness and detects known Game of Life patterns.',
    icon: '‚úÖ'
  },
  {
    title: 'Comprehensive Benchmarking',
    description: 'Built-in performance analysis tools to compare solver backends and optimization strategies across different problem complexities.',
    icon: 'üìä'
  },
  {
    title: 'Multiple Output Formats',
    description: 'Supports text, JSON, and visual representations with evolution path visualization and pattern analysis.',
    icon: 'üì§'
  }
];

const cliCommands = [
  {
    command: 'cargo run -- solve --config config/examples/simple.yaml',
    description: 'Find predecessor states using configuration file with customizable solver backends and optimization levels.'
  },
  {
    command: 'cargo run -- solve --target input/target_states/glider.txt --generations 3 --max-solutions 5',
    description: 'Find multiple predecessor states for a given target configuration with custom parameters.'
  },
  {
    command: 'cargo run -- setup --directory . --force',
    description: 'Initialize project structure with example configurations and target states.'
  },
  {
    command: 'cargo run -- analyze --target input/target_states/blinker.txt',
    description: 'Analyze target state solvability and complexity estimates before attempting to solve.'
  },
  {
    command: 'cargo run -- validate --predecessor p.txt --target t.txt --show-evolution',
    description: 'Validate that a predecessor correctly evolves to the target with complete evolution visualization.'
  }
];

const encodingSteps = [
  {
    number: '1',
    title: 'Primary Variables',
    description: 'Boolean variable <span class="math-term">cell(x, y, t)</span> for each cell at each time step.',
    formula: String.raw`\[ \text{Variables: } \{cell(i,j,t) \mid 0 \leq i < W, 0 \leq j < H, 0 \leq t \leq G\} \]`
  },
  {
    number: '2',
    title: 'Auxiliary Variables',
    description: 'Helper variables for neighbor counts and state transitions to reduce constraint complexity.',
    formula: String.raw`\[ neighbor\_sum(i,j,t,k) = 1 \text{ if } cell(i,j,t) \text{ has } k \text{ live neighbors at } t \]`
  },
  {
    number: '3',
    title: 'State Transition Constraints',
    description: 'Encodes Game of Life rules using CNF clauses derived from the portable FSM-style formulation.',
    formula: String.raw`\[
    (cell(i,j,t) \land (n(i,j,t)=2 \lor n(i,j,t)=3)) \rightarrow cell(i,j,t+1)
    \]`
  }
];

const futureWork = [
  'GPU-accelerated solver for larger grids and multi-generation lookbacks.',
  'Adaptive encoding strategies that switch between exact and relaxed constraints based on clause density.',
  'Interactive visualization improvements for long evolution runs and pattern classification.'
];
---
<SectionShell
  id="optimizations"
  title="Optimizing The Simulation"
  description="Performance notes brought over from the original write-up, organized into a reusable accordion pattern."
  accent
>
  <AccordionGroup title="Engine Architecture">
    {optimizationSections.map((section, index) => (
      <Accordion title={section.title} number={index + 1}>
        <div class="section-text" set:html={section.content}></div>
      </Accordion>
    ))}
  </AccordionGroup>
</SectionShell>

<SectionShell
  id="proof"
  title="Proving Reverse GOL Is NP-Complete"
  description="The original MathJax-heavy proof has been migrated as-is using the new accordion components."
  accent
>
  <AccordionGroup title="Proof Structure">
    {proofSections.map((section, index) => (
      <Accordion title={section.title} number={index + 1}>
        <div class="section-text" set:html={section.content}></div>
      </Accordion>
    ))}
  </AccordionGroup>
</SectionShell>

<SectionShell
  id="implementation"
  title="Implementation: SAT-Based Reverse Solver"
  description="The solver architecture, encoding strategy, and CLI usage copied from the original page."
  accent
>
  <SurfaceCard padding="lg">
    <Heading level={3} size="lg">System Architecture</Heading>
    <Text>The implementation is structured as a modular Rust application with the following core components:</Text>
    <FeatureGrid items={architectureComponents} />
  </SurfaceCard>

  <SurfaceCard padding="lg">
    <Heading level={3} size="lg">SAT Encoding Strategy</Heading>
    <Text>The solver employs a hybrid encoding approach that balances constraint complexity with solving efficiency:</Text>
    <div class="encoding-grid">
      {encodingSteps.map((step) => (
        <SurfaceCard variant="ghost" padding="md" class="encoding-step">
          <div class="encoding-step__number">{step.number}</div>
          <div class="encoding-step__body">
            <h4>{step.title}</h4>
            <p set:html={step.description}></p>
            {step.formula && <div class="formula" set:html={String.raw`${step.formula}`}></div>}
          </div>
        </SurfaceCard>
      ))}
    </div>
  </SurfaceCard>

  <SurfaceCard padding="lg">
    <Heading level={3} size="lg">Command Line Interface</Heading>
    <Text>The solver provides a comprehensive CLI with multiple commands for different use cases:</Text>
    <div class="cli-grid">
      {cliCommands.map((cmd) => (
        <CommandCard command={cmd.command} description={cmd.description} icon="‚å®Ô∏è" />
      ))}
    </div>
  </SurfaceCard>

  <SurfaceCard padding="lg">
    <Heading level={3} size="lg">Core Capabilities</Heading>
    <FeatureGrid items={solverFeatures} />
  </SurfaceCard>

  <SurfaceCard padding="lg">
    <Heading level={3} size="lg">Future Work</Heading>
    <ul class="future-list">
      {futureWork.map((item) => (
        <li>{item}</li>
      ))}
    </ul>
  </SurfaceCard>
</SectionShell>

<Callout variant="info" title="Solver repository">
  <p>
    Ongoing solver experiments, benchmark suites, and release notes live in the dedicated GitHub
    repository. The README includes build instructions for both native and WASM targets.
  </p>
  <Button href="https://github.com/rrumana/game_of_life_reverse" variant="secondary">
    View game_of_life_reverse
  </Button>
</Callout>

<style>
.section-text {
  display: grid;
  gap: var(--space-sm, 0.75rem);
}

.section-text p {
  margin: 0;
  color: var(--color-neutral-500, #5b627a);
}

.section-text .formula {
  font-family: 'Fira Code', monospace;
  font-size: var(--font-size-md, 1rem);
  background: color-mix(in srgb, var(--color-surface-200, #f3f6ff) 50%, transparent);
  padding: var(--space-sm, 0.75rem);
  border-radius: var(--radius-sm, 8px);
  overflow-x: auto;
}

.encoding-grid {
  display: grid;
  gap: var(--space-md, 1.25rem);
}

.encoding-step {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: var(--space-sm, 0.75rem);
  align-items: start;
}

.encoding-step__number {
  width: 2.5rem;
  height: 2.5rem;
  border-radius: 999px;
  display: grid;
  place-items: center;
  background: color-mix(in srgb, var(--color-primary-500, #3b4eff) 18%, transparent);
  font-weight: 700;
}

.encoding-step__body h4 {
  margin: 0 0 var(--space-xs, 0.5rem);
}

.encoding-step__body p {
  margin: 0 0 var(--space-xs, 0.5rem);
}

.cli-grid {
  display: grid;
  gap: var(--space-sm, 0.75rem);
}

.future-list {
  margin: 0;
  padding-left: 1.25rem;
  display: grid;
  gap: var(--space-xs, 0.5rem);
  color: var(--color-neutral-500, #5b627a);
}

.code-snippet {
  font-family: 'Fira Code', monospace;
  background: color-mix(in srgb, var(--color-primary-500, #3b4eff) 12%, transparent);
  padding: 0 0.25rem;
  border-radius: 4px;
}

html[data-theme='dark'] .section-text p,
html[data-theme='dark'] .future-list {
  color: var(--color-neutral-500, #9aa7d6);
}

html[data-theme='dark'] .section-text .formula {
  background: color-mix(in srgb, var(--color-surface-300, #14203c) 60%, transparent);
}
</style>
